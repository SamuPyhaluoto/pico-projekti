

//hoitaa anturien käsittelyn ja niiden datan lukemisen.


#include <tkjhat/sdk.h>


#include "hardware/irq.h"
#include "hardware/pwm.h"
#include <tkjhat/ssd1306.h>
#include <tkjhat/pdm_microphone.h>
#include <stdio.h>
#include <math.h>
#include <hardware/i2c.h>


/* =========================
 *  ICM-42670 (IMU)
 * ========================= */

// IMU related function
// https://invensense.tdk.com/wp-content/uploads/2021/07/DS-000451-ICM-42670-P-v1.0.pdf

float aRes, gRes;      // scale resolutions per LSB for the sensors

static int icm_i2c_write_byte(uint8_t reg, uint8_t value) {
    uint8_t buf[2] = { reg, value };
    int result = i2c_write_blocking(i2c_default, ICM42670_I2C_ADDRESS, buf, 2, false);
    return result == 2 ? 0 : -1;
}

// helper to read a byte from a register
static int icm_i2c_read_byte(uint8_t reg, uint8_t *value) {
    int result = i2c_write_blocking(i2c_default, ICM42670_I2C_ADDRESS, &reg, 1, true);
    if (result != 1) return -1;
    result = i2c_read_blocking(i2c_default, ICM42670_I2C_ADDRESS, value, 1, false);
    return result == 1 ? 0 : -1;
}

static int icm_i2c_read_bytes(uint8_t reg, uint8_t *buffer, uint8_t len) {
    int result = i2c_write_blocking(i2c_default, ICM42670_I2C_ADDRESS, &reg, 1, true);
    if (result != 1) return -1;
    result = i2c_read_blocking(i2c_default, ICM42670_I2C_ADDRESS, buffer, len, false);
    return result == len ? 0 : -2;
}

static int icm_soft_reset(void) {
    int rc = icm_i2c_write_byte(ICM42670_REG_SIGNAL_PATH_RESET, ICM42670_RESET_CONFIG_BITS);
    sleep_us(400);   // small wait: datasheet calls for ~200 µs before other writes
    //TODO: For making more robust. Wait till the MCKL_READY is on (clock is running again)
    return rc;
}

//TRY TO SOLVE PROBLEM OF FLOATING AD0 pin, JUST IN CASE THE ADDRESS IS CHANGING. 
static int ICM42670_autodetect_address(void) {
    const uint8_t cand[2] = { ICM42670_I2C_ADDRESS, ICM42670_I2C_ADDRESS_ALT };
    for (int i = 0; i < 2; ++i) {
        // Try a few times to avoid picking up a one-off glitch
        int hits = 0;
        for (int t = 0; t < 4; ++t) {
            uint8_t who = 0, reg = ICM42670_REG_WHO_AM_I;
            if (i2c_write_blocking(i2c_default, cand[i], &reg, 1, true) != 1) continue;
            if (i2c_read_blocking(i2c_default, cand[i], &who, 1, false) != 1) continue;
            if (who == ICM42670_WHO_AM_I_RESPONSE) ++hits;
        }
        if (hits >= 3) { return cand[i]; } // majority wins
    }
    return -1;
}

//TODO do initial calibration. 
static void calibrateAccel(float *dest1){

}

static void calibrateGyro(float *dest2){


}

int init_ICM42670() {
    blink_led(5);
    
    //Soft reset
    icm_soft_reset();

    //DETECT ADDRESS FOR AD0 floating pin: 
    int address = ICM42670_autodetect_address();
    if (address == -1){
        printf("Address could not be found");
    }
    else 
        printf ("Address: 0x%02X\n",address);
    // Step 1: Check WHO_AM_I
    uint8_t who = 0;
    if (icm_i2c_read_byte(ICM42670_REG_WHO_AM_I, &who) != 0) {
        return -2;
    };
    if (who != ICM42670_WHO_AM_I_RESPONSE) {
        return -3;
    };   

    // Step 2: Configure INT1 pin - push-pull, active-low, pulsed
    if(icm_i2c_write_byte(ICM42670_INT_CONFIG, ICM42670_INT1_CONFIG_VALUE) != 0){ 
        return -4;
    }
    // tiny guard delay after init writes
    sleep_us(200);
    
    // Step 3: Success
    return 0;
}

int ICM42670_startAccel(uint16_t odr_hz, uint16_t fsr_g) {
    uint8_t fsr_bits = 0;
    uint8_t odr_bits = 0;

    // Map FSR to register bits, aRes (See Datasheet Table 2)
    switch (fsr_g) {
        case 2:  
            fsr_bits = ICM42670_ACCEL_FSR_2G;
            aRes = 16384; 
            break;
        case 4:  
            fsr_bits = ICM42670_ACCEL_FSR_4G;
            aRes = 8192;
            break;
        case 8:  
            fsr_bits = ICM42670_ACCEL_FSR_8G; 
            aRes =4096;
            break;
        case 16: 
            fsr_bits = ICM42670_ACCEL_FSR_16G;
            aRes = 2048;
            break;
        default: return -1; // invalid FSR
    }

    // Map ODR to register bits
    switch (odr_hz) {
        case 25:   odr_bits = ICM42670_ACCEL_ODR_25HZ; break;
        case 50:   odr_bits = ICM42670_ACCEL_ODR_50HZ; break;
        case 100:  odr_bits = ICM42670_ACCEL_ODR_100HZ; break;
        case 200:  odr_bits = ICM42670_ACCEL_ODR_200HZ; break;
        case 400:  odr_bits = ICM42670_ACCEL_ODR_400HZ; break;
        case 800:  odr_bits = ICM42670_ACCEL_ODR_800HZ; break;
        case 1600: odr_bits = ICM42670_ACCEL_ODR_1600HZ; break;
        default:   return -2; // invalid ODR
    }

    // Combine into ACCEL_CONFIG0: [7:5] = fsr, [3:0] = odr
    uint8_t accel_config0_val = (fsr_bits << 5) | (odr_bits & 0x0F);
    int rc = icm_i2c_write_byte(ICM42670_ACCEL_CONFIG0_REG, accel_config0_val);
    sleep_us(200); 
    if (rc != 0) return -3;
    return 0; // success
}

int ICM42670_startGyro(uint16_t odr_hz, uint16_t fsr_dps) {
    uint8_t fsr_bits = 0;
    uint8_t odr_bits = 0;
 
    // Map FSR, gRes (See Datasheet Table 1)
    switch (fsr_dps) {
        case 250:  
            fsr_bits = 0x03;
            gRes = 131; 
            break;
        case 500:  
            fsr_bits = 0x02;
            gRes = 65.5;
            break;
        case 1000: 
            fsr_bits = 0x01;
            gRes = 32.8;
            break;
        case 2000: 
            fsr_bits = 0x00;
            gRes = 16.4;
            break;
        default:   return -1;
    }

    // Map ODR
    switch (odr_hz) {
        case 25:   odr_bits = 0x0B; break;
        case 50:   odr_bits = 0x0A; break;
        case 100:  odr_bits = 0x09; break;
        case 200:  odr_bits = 0x08; break;
        case 400:  odr_bits = 0x07; break;
        case 800:  odr_bits = 0x06; break;
        case 1600: odr_bits = 0x05; break;
        default:   return -2;
    }

    // Write GYRO_CONFIG0
    uint8_t gyro_config0_val = (fsr_bits << 5) | (odr_bits & 0x0F);
    if (icm_i2c_write_byte(ICM42670_GYRO_CONFIG0_REG, gyro_config0_val) != 0) return -3;
    sleep_us(200); 
    return 0;
}

//put in low noise both acc and gyr
int ICM42670_enable_accel_gyro_ln_mode() {
    int rc = icm_i2c_write_byte(ICM42670_PWR_MGMT0_REG , 0x0F); // bits 3:2 = gyro LN, bits 1:0 = accel LN
    sleep_us(200);
    return rc;
}

//Remove gyro and low power mode for accelearoter
int ICM42670_enable_ultra_low_power_mode(void) {
    // Accel = LP (10), Gyro = OFF (00)
    // PWR_MGMT0 = 0b00000010 = 0x02
    int rc = icm_i2c_write_byte(ICM42670_PWR_MGMT0_REG , 0x02);
    sleep_us(200);
    return rc;
}

//Both gyro and acceleremoter in low power. Usually the gyro has lot of errors. 
int ICM42670_enable_accel_gyro_lp_mode(void) {
    // Gyro = 10 (LP), Accel = 10 (LP)
    // 0b00001010 = 0x0A
    int rc = icm_i2c_write_byte(ICM42670_PWR_MGMT0_REG, 0x0A);
    sleep_us(200);
    return rc;
}

int ICM42670_start_with_default_values(void) {
    int rc;

    // Start accelerometer with defaults (e.g., 100 Hz, ±4 g)
    rc = ICM42670_startAccel(ICM42670_ACCEL_ODR_DEFAULT,
                             ICM42670_ACCEL_FSR_DEFAULT);
    if (rc != 0) return rc;

    // Start gyroscope with defaults (e.g., 100 Hz, ±250 dps)
    rc = ICM42670_startGyro(ICM42670_GYRO_ODR_DEFAULT,
                            ICM42670_GYRO_FSR_DEFAULT);
    if (rc != 0) return rc;

    // Put both sensors into Low-Noise mode
    rc = ICM42670_enable_accel_gyro_ln_mode();
    if (rc != 0) return rc;

    return 0;
}


int ICM42670_read_sensor_data(float *ax, float *ay, float *az,
    float *gx, float *gy, float *gz,float *t) {
        
        uint8_t raw[14]; // 14 bytes total from TEMP to GYRO Z

        int rc = icm_i2c_read_bytes(ICM42670_SENSOR_DATA_START_REG, raw, sizeof(raw));
        if (rc != 0) return rc;

        // Convert to signed 16-bit integers (big-endian)
        int16_t t_raw = (int16_t)((raw[0] << 8) | raw[1]);
        int16_t ax_raw = ((int16_t)raw[2] << 8) | raw[3];
        int16_t ay_raw = ((int16_t)raw[4] << 8) | raw[5];
        int16_t az_raw = ((int16_t)raw[6] << 8) | raw[7];
        int16_t gx_raw = (int16_t)((raw[8] << 8) | raw[9]);
        int16_t gy_raw = (int16_t)((raw[10] << 8) | raw[11]);
        int16_t gz_raw = (int16_t)((raw[12] << 8) | raw[13]);

        *t = ((float)t_raw / 128.0f)+ 25.0;
        *ax =  (float)ax_raw / aRes; 
        *ay =  (float)ay_raw / aRes; 
        *az =  (float)az_raw / aRes;
        *gx =  (float)gx_raw / gRes; 
        *gy =  (float)gy_raw / gRes; 
        *gz =  (float)gz_raw / gRes;
        return 0; // success
}